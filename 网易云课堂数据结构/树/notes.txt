二分查找判定树：
・判定树上每个节点结点需要查找的次数恰好为该结点所在的层数；
・查找成功时查找次数不会超过判定树的深度；
・n个结点的判定树的深度为[logN]+1；
・ASL（平均成功查找次数）： (4*4+4*3+2*2+1) / 11 = 3 (11个元素的判定树)；

树与非树：
    ・子树是不相交的；
    ・除了根节点外，每个结点有且仅有一个父节点；
    ・一棵N个结点的树有N-1条边。

树的一些基本术语：
    1.结点的度(Degree):结点的子树个数。
    2.树的度：树的所有结点中最大的度。
    3.叶节点(Leaf)：度为0的结点。
    4.父节点(Parent)：有子树的结点是其子树的根结点的父结点。
    5.子结点(Child)：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点。
    6.兄弟结点(Sibling)：具有同一父结点的各结点彼此是兄弟结点。
    7.路径和路径长度：从结点n1到nk的路径为一个结点序列n1,n2,...,nk,ni是ni+1的父结点。路径所包含的个数为路径的长度。
    8.祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。
    9.子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。
    10.结点的层次(Level)：规定根节点在1层，其他任一结点的层数是其父结点的层数加1。
    11.树的深度(Depth)：树中所有结点中的最大层次是这棵树的深度。

树的表示方法：
    ・儿子兄弟表示法（旋转45°引出二叉树）
    
二叉树的抽象数据类型定义：
类型名称：二叉树
数据对象集：一个有穷的结点集合
    若不为空，则由根结点和其左、右二叉子树组成。
操作集：BT ∈ BinTree, Item ∈ ElementType, 重要操作有：
    1.Boolean IsEmpty(BinTree BT)：判别BT是否为空；
    2.void Traversal(BinTree BT)：遍历，按某种顺序访问每个结点；
    3.BinTree CreateBinTree()：创建一个二叉树。
常见的遍历方法有：
    ・void PreOrderTraversal(BinTree BT)：先序遍历-----根、左、右
    ・void InOrderTraversal(BinTree BT)：中序遍历-----左、根、右
    ・void PostOrderTraversal(BinTree BT)：后序遍历-----左、右、根
    ・void LevelOrderTraversal(BinTree BT)：层次遍历-----从上到下、从左到右

二叉树的存储结构：
    1.顺序存储结构：
      完全二叉树：从上至下、从左到右顺序存储n个结点的完全二叉树的结点父子关系：
		  ・非根节点（序号i>1）的父结点的序号是i/2向下取整；
		  ・结点（序号为i）的左孩子的结点的序号是2i（须2i<=n，否则没有左孩子）；
		  ・结点（序号为i）的右孩子结点的序号是2i+1（须2i+1<=n，否则没有右孩子）。
    2.链表存储结构：
	typedef struct TreeNode *BinTree;
	typedef BinTree Position;
	struct TreeNode{
		ElementType Data;
		BinTree Left;
		BinTree Right;
	}
设深度为d（只有一个根结点时，d为1）的二叉树只有度为0和2的结点，则此类二叉树的结点数至少为2d-1。